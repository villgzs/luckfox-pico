1. Port Forwarding beállítása (PICO oldal)
A routered admin felületén irányítsd át az UDP 51820-as portot a PICO belső IP címére.

Fontos: A WireGuard UDP-t használ, nem TCP-t!

-----------------------------------------------------

2. PICO (Szerver) konfiguráció
Fájl: /etc/wireguard/wg0.conf

Ini, TOML
[Interface]
Address = 10.0.0.1/24
ListenPort = 51820
PrivateKey = <PICO_PRIVAT_KULCS>

# Ez a B_COMPUTER (Kliens)
[Peer]
PublicKey = <B_COMPUTER_PUBLIKUS_KULCS>
AllowedIPs = 10.0.0.2/32


-----------------------------------------------------

3. B_COMPUTER (Kliens) konfiguráció
Fájl: wg0.conf (Windows-on vagy Linuxon)

Ini, TOML
[Interface]
Address = 10.0.0.2/24
PrivateKey = <B_COMPUTER_PRIVAT_KULCS>

[Peer]
PublicKey = <PICO_PUBLIKUS_KULCS>
# Itt a PICO routerének KÜLSŐ (Internet) IP címét add meg!
Endpoint = <PICO_KULSO_IP>:51820
AllowedIPs = 10.0.0.0/24
# Ez tartja nyitva az alagutat a NAT-on keresztül:
PersistentKeepalive = 25

-------------------------------------------------------

Miért a PICO legyen a szerver?
Bár a PICO az erőforrás-szegényebb eszköz, a hálózati elrendezésed miatt ő az egyetlen, aki "hívható". Mivel a WireGuard kernel-szinten fut, a PICO észre sem fogja venni a forgalmat, amíg nem küldesz rajta gigabájtokat.

Amire figyelned kell (PICO specifikus):
Dinamikus IP: Ha a PICO routere nem fix IP-t kap a szolgáltatótól (Kábelmodemnél gyakori), akkor szükséged lesz egy DDNS-re (pl. DuckDNS vagy No-IP), és az Endpoint sorba az IP helyett a domain nevet kell írnod.

Tűzfal: Ha a PICO-n fut az ufw, engedélyezd a portot:
sudo ufw allow 51820/udp

Boot sebesség: Most, hogy már szupergyors a bootod, a WireGuard indítása hozzá fog adni kb. 0.5-1 másodpercet. Ha ez zavar, használhatod a korábbi & trükköt az indításnál.

----------------------------------------------------------

Hogyan teszteld?
Ha mindkét oldalon elindítottad (wg-quick up wg0), a B_COMPUTER-ről add ki ezt a parancsot:
ping 10.0.0.1

Ha válaszol a PICO, akkor a két gép egy virtuális szobába került.

Szeretnéd, hogy segítsen generálni a kulcspárokat, vagy megvan a parancs hozzá?

--------------------------------------------------------------------------
--------------------------------------------------------------------------

Ez a klasszikus Site-to-Site vagy Peer-to-Peer felállás. Mivel a Pico-d memóriája véges, a cél az, hogy a VPN ne csak biztonságos legyen, hanem "láthatatlan" is a rendszererőforrások számára.

A WireGuard erre a legtökéletesebb, mert nem egy központi szerveren keresztül rángatja az adatokat (mint a legtöbb kereskedelmi VPN), hanem közvetlen alagutat nyit a két gép között.

A stratégia: "L2TP helyett tiszta L3 alagút"
Ahhoz, hogy úgy lássák egymást, mintha egy szobában lennének, a következő adatokra lesz szükséged:

Gép "A" (Pico): IP címe a VPN-en belül: 10.0.0.1

Gép "B" (Másik gép): IP címe a VPN-en belül: 10.0.0.2

1. Beállítás a Pico-n (/etc/wireguard/wg0.conf)
Feltételezve, hogy a másik gépnek van publikus IP címe (vagy a routerén át van irányítva az 51820-as port):

Ini, TOML
[Interface]
PrivateKey = <Pico_privát_kulcsa>
Address = 10.0.0.1/24
ListenPort = 51820

[Peer]
PublicKey = <Másik_gép_publikus_kulcsa>
Endpoint = <Másik_gép_külső_IP_címe>:51820
AllowedIPs = 10.0.0.2/32
PersistentKeepalive = 25
2. Beállítás a másik gépen (Gép "B")
Ha ez egy Windowsos gép vagy egy másik Linux, a konfiguráció tükörképe lesz az előzőnek:

Ini, TOML
[Interface]
PrivateKey = <Másik_gép_privát_kulcsa>
Address = 10.0.0.2/24
ListenPort = 51820

[Peer]
PublicKey = <Pico_publikus_kulcsa>
Endpoint = <Pico_külső_IP_címe>:51820
AllowedIPs = 10.0.0.1/32
Miért fontos az AllowedIPs?
Ez a beállítás mondja meg a Linuxnak, hogy ha a 10.0.0.x tartományba küldesz adatot, azt ne az interneten, hanem a VPN alagúton keresztül küldje. Így ha a Pico-n kiadod a ping 10.0.0.2 parancsot, a másik gép válaszolni fog, mintha a helyi hálózaton lenne.

Mi a helyzet, ha egyik gép sem publikus? (NAT-to-NAT)
Ez a leggyakoribb probléma: mindkét gép router mögött van, és nem tudsz portot nyitni.

A rossz hír: A tiszta WireGuardhoz legalább az egyik oldalon kell egy nyitott port.

A megoldás a Pico-hoz: Keress egy filléres (vagy ingyenes "Always Free") mikroszervert (pl. Oracle Cloud vagy egy kicsi VPS), ami "közvetítőként" (Relay) szolgál. Mindkét gép rácsatlakozik a szerverre, és a szerver összeköti őket.

Hálózati megosztás (opcionális)
Ha azt szeretnéd, hogy a Pico-n keresztül a hálózaton lévő többi eszközt is elérd (nem csak magát a Pico-t), akkor be kell kapcsolnod az IP forwardingot:

Bash
echo "net.ipv4.ip_forward=1" | sudo tee -a /etc/sysctl.conf
sudo sysctl -p
Következő lépés:
Van a két gép közül valamelyiknek fix publikus IP címe, vagy mindkettő otthoni/irodai router mögött van? (Ez dönti el, hogy kell-e harmadik fél a kapcsolatba.)

------------------------------------------------------------------------
------------------------------------------------------------------------

Mi a helyzet, ha okostelefon-ról szeretném megoldani a kapcsolódást a PICO-hoz?

A Gemini ezt mondta:
Ez a legjobb hír, mert a WireGuard kifejezetten "mobilbarát": nem meríti az akkumulátort (nem küld adatot, ha nincs forgalom) és pillanatok alatt újracsatlakozik, ha váltasz 4G-ről Wi-Fi-re.

A telefonod ugyanolyan Kliens (Peer) lesz, mint a B_COMPUTER. A PICO-n csak annyit kell tenned, hogy hozzáadsz még egy "Peer" szekciót.

1. PICO felkészítése (Szerver oldal)
Módosítsd a /etc/wireguard/wg0.conf fájlt a PICO-n, hogy fogadni tudja a telefont:

Ini, TOML
[Interface]
Address = 10.0.0.1/24
ListenPort = 51820
PrivateKey = <PICO_PRIVAT_KULCS>

# Eredeti B_COMPUTER
[Peer]
PublicKey = <B_COMPUTER_PUBLIKUS_KULCS>
AllowedIPs = 10.0.0.2/32

# ÚJ: Okostelefon
[Peer]
PublicKey = <TELEFON_PUBLIKUS_KULCS>
AllowedIPs = 10.0.0.3/32
Mentsd el, majd indítsd újra a WireGuardot: sudo systemctl restart wg-quick@wg0.

2. Okostelefon beállítása (A legegyszerűbb módszer)
Ne gépelj a telefonon! Használd a QR-kódos módszert.

Telepítsd a WireGuard appot (Play Áruház vagy App Store).

Generálj egy konfigot a telefonnak a PICO-n egy ideiglenes fájlba (pl. phone.conf):

Ini, TOML
[Interface]
Address = 10.0.0.3/24
PrivateKey = <TELEFON_SAJAT_PRIVAT_KULCSA>
DNS = 1.1.1.1

[Peer]
PublicKey = <PICO_PUBLIKUS_KULCSA>
Endpoint = <PICO_KULSO_IP>:51820
AllowedIPs = 0.0.0.0/0  # Ha mindent a VPN-en keresztül akarsz küldeni
# VAGY: AllowedIPs = 10.0.0.0/24 # Ha csak a PICO-t akarod elérni
PersistentKeepalive = 25
Telepítsd a qrencode csomagot a PICO-ra:
sudo apt install qrencode

Generálj QR-kódot a terminálban:
qrencode -t ansiutf8 < phone.conf

Az appban válaszd a "+" gombot -> Scan from QR code lehetőséget, és olvasd be a terminálból.

Mire tudod így használni?
SSH a zsebedből: Bárhol vagy a világon, megnyitsz egy terminál appot a telefonon (pl. Termius vagy JuiceSSH), beírod, hogy pico@10.0.0.1, és már bent is vagy a Pico-n.

Webfelület: Ha fut a Pico-n egy webszerver (pl. egy szenzoradatokat mutató Python Flask oldal), a telefon böngészőjében a http://10.0.0.1 címen eléred.

Biztonság: Ha az AllowedIPs = 0.0.0.0/0 beállítást használod, a telefonod teljes internetforgalma a Pico-n (és az otthoni kábelmodemeden) keresztül megy át, ami hasznos lehet publikus Wi-Fi használatakor.

Egy fontos apróság:
A PICO kábelmodemének külső IP címe néha megváltozhat. Ha ez megtörténik, a telefon nem fogja találni a Pico-t.
Megoldás: Használj egy ingyenes DDNS-t (pl. pico-home.duckdns.org), és a telefonon az Endpoint sorban az IP helyett ezt add meg.

Szeretnéd, hogy segítsen generálni a telefonhoz szükséges kulcsokat és a konfigot?

------------------------------------------------------------------------------------------------------------

Mivel a Pico memóriája (56 MiB) rendkívül szűkös, a "kevesebb több" elve alapján kell válogatnunk. A cél, hogy a VPN-ed stabil legyen, de maradjon hely a saját alkalmazásodnak is.

Itt a lista a javasolt, "Pico-barát" csomagokról:

1. A VPN alapjai (WireGuard)
Ez a legfontosabb, amit kértél. Ne telepíts nehéz kezelőfelületeket, csak az alap eszközöket:

wireguard: A kernel modul és az alap parancsok.

wireguard-tools: Ez tartalmazza a wg és wg-quick parancsokat.

qrencode: (Opcionális) Ezzel tudsz QR-kódot rajzolni a terminálba, hogy a telefonodat 1 másodperc alatt csatlakoztasd.

Bash
sudo apt update
sudo apt install wireguard wireguard-tools qrencode
2. Rendszerdiagnosztika (A memória szemmel tartásához)
Mivel optimalizáltuk a rendszert, látni akarod, ha valami "elszabadul":

htop: Sokkal olvashatóbb, mint a top, és látod rajta a CPU magok terhelését is.

iotop: Megmutatja, ha valami folyamatosan írja az SD kártyát (ami tönkreteheti azt).

ncdu: Ha elfogyna a hely a 12G-s kártyán, ez megmutatja, melyik mappa a bűnös.

Bash
sudo apt install htop iotop ncdu
3. Hálózati segédeszközök
A VPN teszteléséhez és a távoli eléréshez:

iputils-ping: Alapvető teszteléshez.

iperf3: (Csak teszt idejére) Ezzel meg tudod mérni, mekkora a tényleges sebesség a Pico és a telefonod/PC-d között a VPN-en keresztül.

tcpdump: Ha nem látják egymást a gépek, ezzel tudod "lehallgatni" a forgalmat, hogy egyáltalán megérkeznek-e a csomagok az 51820-as porton.

4. Amit NE telepíts (vagy távolíts el)
Hogy megőrizd a villámgyors boot időt és a szabad RAM-ot:

Ne telepíts: NetworkManager-t (maradj az /etc/network/interfaces-nél).

Ne telepíts: Docker-t (a Pico 56 MB RAM-ja ehhez nagyon kevés, a konténerek megennék reggelire).

Távolítsd el, ha fent van: snapd (ez az Ubuntu legnagyobb memóriazabálója).

Bash
sudo apt purge snapd
5. Fejlesztéshez
Ha Pythonban írsz programot a Pico-ra, a pip helyett próbáld a rendszercsomagokat használni, vagy használj virtualenv-et, de csak nagyon célzottan.

------------------------------------------------------------------------------------------------------------------------

sudo apt update
sudo apt install wireguard-go

sudo nano /etc/wireguard/wg0.conf

sudo wireguard-go wg0

mkdir -p /dev/net
mknod /dev/net/tun c 10 200
chmod 600 /dev/net/tun

Ha a célod "csak" az, hogy a távoli B számítógépről elérd a Pico-t (vagy a Pico-n keresztül a B gépen futó webszervert), és a VPN-be beletört a bicskánk a hiányzó TUN driver miatt, használhatjuk az SSH Tunneling-et.

Ez nem igényel semmilyen kerneltámogatást, se TUN-t, se WireGuard-ot, mert a titkosított alagutat maga az SSH protokoll építi fel "user" szinten.

Hogyan irányítsd a HTTP kérést a Pico-ról a B gépre SSH-val?
Mivel a Pico-ra be tudsz SSH-zni (vagy ő ki a B gépre), használd a Remote Port Forwarding-ot.

A B gépen (ahol a webszerver fut) futtasd ezt (a Pico felé kapcsolódva):

Bash
ssh -R 8080:localhost:80 user@pico_ip_cime
Ekkor a Pico-n megnyílik a 8080-as port, ami valójában a B gép 80-as portjára mutat.

A Pico-n most már az iptables segítségével a routerről érkező kéréseket át tudod dobni a localhost:8080-ra.
-----------------------------------------------------------------
1. Lépés: SSH alagút felépítése (B gépről)
A B számítógépen (ahol a weboldalad fut) add ki ezt a parancsot:

Bash
ssh -R 8080:localhost:80 user@pico_ip_cime
-R: Remote port forwarding.

8080: Ezen a porton fog figyelni a Pico.

localhost:80: Ide dobja tovább a forgalmat a B gépen belül.

user@pico_ip_cime: A Pico-ra jelentkezel be.

Fontos: Ezt a terminált hagyd nyitva! Ha bezárod, az alagút összeomlik. (Később megmutatom, hogyan futtasd a háttérben autossh-val).


2. Lépés: A Pico felkészítése (GatewayPorts)
Alapértelmezésben az SSH biztonsági okokból csak a 123.0.0.1 (localhost) felől fogad kéréseket az alagúton. Hogy a routered felől (kívülről) is elérhető legyen, ezt engedélyezni kell:

Szerkeszd a Pico-n az SSH konfigot:
sudo nano /etc/ssh/sshd_config

Keresd meg és állítsd be (vagy add hozzá):
GatewayPorts yes

Indítsd újra az SSH-t:
sudo systemctl restart ssh

# IP forwarding bekapcsolása (ha még nem tetted)
sudo sysctl -w net.ipv4.ip_forward=1

# Ami a Pico 80-as portjára jön, azt dobjuk át a belső 8080-asra
sudo iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080

-----------------------------------------------------------------

Látogató -> Router (9080) -> Pico (80) -> SSH Alagút (Pico 8080) -> B Computer (80)

1. Lépés: SSH alagút felépítése (B gépről)
A B gépen add ki a parancsot, ami összeköti a Pico-t a saját webszervereddel:

ssh -R 8080:localhost:80 user@pico_belso_ip_cime

2. Lépés: A Pico beállítása (A "Híd")
Mivel a kérések a Pico 80-as portjára érkeznek a routertől, de az SSH alagút a 8080-ason várja őket, a Pico-n össze kell kötnünk a kettőt.

A, Engedélyezd a külső kéréseket az SSH-ban:
Szerkeszd a Pico-n a fájlt: sudo nano /etc/ssh/sshd_config
Állítsd be:

Plaintext
GatewayPorts yes
Mentsd el, és indítsd újra: sudo systemctl restart ssh

B, Az átirányítás beállítása (iptables):
Futtasd a Pico-n (rootként):

Bash
# Töröljük az esetleges korábbi kísérleteket a tisztánlátás végett
sudo iptables -t nat -F

# Ami a 80-as portra érkezik, azt dobjuk át a belső 8080-asra
sudo iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080
3. Lépés: Ellenőrzés
A Pico-n: Nézd meg, látod-e az SSH-t figyelni:
netstat -tpln | grep 8080
(Ha azt látod: 0.0.0.0:8080, akkor a GatewayPorts sikerült. Ha 127.0.0.1:8080, akkor csak a Pico-ról éred el.)

A Routeren: Ellenőrizd a Port Forwarding szabályt:
Külső Port: 9080 -> Pico IP: 80 (TCP)

Külső teszt: Próbáld megnyitni a böngészőben:
http://a_te_publikus_ip_cimed:9080

------------------------------------------------------------

Így néz ki a végleges láncolat:Látogató → Router (9080) → Pico (80) → SSH Tunel → B Computer (8080)

1. Az SSH alagút indítása a B géprőlFuttasd ezt a parancsot a B számítógépen:Bash

ssh -R 80:localhost:8080 user@pico_ip_cime

Magyarázat:-R 80: Azt mondja a Pico-nak: "Figyelj a 80-as portodon." (Mivel a Pico-n a 80-as port szabad, és a routered oda küldi a kérést, ez a legpraktikusabb).localhost:8080: "Bármit, ami a Pico 80-asára érkezik, küldd vissza nekem ide, a saját 8080-as portomra."user@pico_ip_cime: A Pico elérhetősége.

Megjegyzés: Ha a Pico-n nem root-ként vagy bejelentkezve az SSH-val, előfordulhat, hogy nem engedi a 80-as portot (1024 alatti portokhoz kiváltság kell). 

Ha hibát kapsz, használd a korábbi 8080:localhost:8080 felállást, és marad az iptables REDIRECT a Pico-n.

2. Ha a 80-as port "Permission Denied" (Pico oldal)

Ha az SSH alagút indításakor a B gép azt írja, hogy Privileged ports can only be forwarded by root, akkor két választásod van:A) 

A "tiszta" út (root SSH):Engedélyezed a Pico-n a root belépést (vagy a 80-as port használatát az SSH-nak), és így csatlakozol:ssh -R 80:localhost:8080 root@pico_ip_cimeB) 

Az "átirányítós" út (Ajánlott):Maradunk a korábbi tervnél: az alagút a 8080-ason jön létre, és a Pico-n belül "kötjük át" a forgalmat a 80-asról.

B gépen: ssh -R 8080:localhost:8080 user@pico_ip_cimePico-n (GatewayPorts engedélyezése után):Bash

sudo iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080

3. Ellenőrzés (Lépésről lépésre)Futtasd ezeket a Pico-n, hogy lásd, él-e a kapcsolat:Figyel-e az SSH az alagútra?netstat -tpln | grep 8080 (vagy 80, attól függően, melyiket választottad).Cél: 0.0.0.0:8080 vagy *:8080 látszódjon.Átmennek-e a csomagok?Futtasd a Pico-n: sudo tcpdump -i any port 80 or port 8080Majd próbáld megnyitni a weboldalt kívülről. Ha látsz pörgő sorokat, a csomagok megérkeztek a Pico-ra és elindultak a B gép felé.Összegzés a beállításhoz:EszközFeladatRouter9080 (külső) → Pico 80 (belső) továbbítás.PicoGatewayPorts yes az /etc/ssh/sshd_config-ban + SSH újraindítás.B Computerssh -R 8080:localhost:8080 user@pico futtatása.Picoiptables REDIRECT 80-asról 8080-asra.




